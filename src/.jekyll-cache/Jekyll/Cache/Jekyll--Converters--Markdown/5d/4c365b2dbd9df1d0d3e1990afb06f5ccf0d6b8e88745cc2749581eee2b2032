I"%B<ul>
  <li><a href="15.4">추상화</a></li>
</ul>

<h1 id="추상화">추상화</h1>
<hr />

<p>객체지향 개발에서 추상화 개념은 매우 중요하다.</p>

<p>모든 것을 자세히 표현해야 하는것에 해당되어 개략적인 것만 이야기 할 수 있도록 해준다.</p>

<p>추상
중요하지 않은 부분을 생략, 개괄적으로 표현하는 것을 추상활라 한다. 
최근 객체지향에서는 추상화 가 매우 중요하다.</p>

<p>추상화는 복잡한 것을 단순화 하고 이해하기 쉽게 모델을 만드는데 좋은 방법입니다.</p>

<p>동작을 이해하는데 있어서 실제 세부 내용 하나 하나를 다 알 필요는 없습니다. 대략적인 동작의 형태와 모습, 결과만 알면 되는 것입니다.</p>

<p>그리고 추상화는 프로그램의 세부를 분석하지 않아도 대략적인 동작을 이해하기 좋습니다. 이런 의미에서 추상화를 많이 사용합니다.</p>

<p>객체지향 패러다임에서 추상화 기법은 많이 사용이 됩니다.</p>

<p>추상화는 객체를 동일한 타입으로 분류, 공유를 할 수 있습니다.</p>

<p>추상화는 복잡성을 낮추기 위한 것입니다.</p>

<p>일반화와 특수화
일반화란 공통적인 부분을 강조하는 것을 말합니다. 특수화는 일반화의 반대말입니다. 서로의 차이점을 강조하는 것을 말합니다.</p>

<p>동일한 추상화
추상화는 객체지향의 큰 장점입니다. 추상화를 통하여 코드를 작성, 분석하는데 있어서 일관성 있게 적용을 할 수 있는 장점이 있습니다.</p>

<p>분류
분류는 공통점을 기반으로 객체를 바라 보는 것입니다.	유사한 특성을 중점으로 분류 합니다.</p>

<p>이처럼 객체를 분류하는 것은 하나의 공통된 개념으로 바라보기 위한 것입니다.</p>

<p>추상화는 공통된 부분만을 묽어 개념적으로 바라보는 것일뿐, 각각의 객체가 모두 동일한 것은 아니다. 각각의 객체마다 고유한 값과 상태를 가지고 있다.</p>

<p>하지만 추상적으로 이를 묽어서 처리하는 것은 복잡성을 제거하기 위해서 입니다.</p>

<p>타입확인
하나의 개념을 타입이라고 한다. 타입의 역은 객체를 생성하는 인스턴스화를 말합니다. 객체는 타입의 인스턴스이다.</p>

<p>타입을 알기 위해서는 객체를 확인하여야 한다.
어떤 객체의 타입</p>

<p>16.1 추상화란
추상클래스는 클래스 계층 구조에서 상위 클래스에서 구현해야 되는 메소드를 하위 클래스에서 구현을 하도록 요청을 합니다.</p>

<p>추상은 영어로 abstract라고 합니다.
추상클래스를 생성을 할때는 abstract라는 키워드를 같이 사용해 주어야 합니다.</p>

<p>객체생성
추상클래스는 클래스 선언만으로 객체를 생성할 수 없습니다.
생성 가능한 객체는 추상클래스를 상속받은 클래스만 객체로 생성을 할 수 있습니다.</p>

<p>추상클래스로 객체를 생성할 수 없는 이유는 추상 클래스안에는 구체적인 클래스의 내용이 없기 때문입니다.</p>

<p>추상클래스의 객체생성
추상클래스는 혼자만으로 객체를 생성할 수 없습니다.
객체를 생성하게 되면 오류가 발생합니다.</p>

<p>추상클래스 상속
추상클래스를 상속합니다. 상속만으로 추상클래스를 사용할 수 있는 것이 아닙니다. 추상클래스에 있는 추상 메소드에 대한 구현을 해주어야 합니다.</p>

<p>추상구현
추상 클래스를 상속을 받게 되면, 추상 메소드에 대한 구현을 해주어야 합니다.
구체적인 추상 메소드의 내용을 구현해 주지 않으면 오류가 발생합니다.</p>

<p>추상 메소드의 특징은 실제가 없습니다. 실체는 상속받은 클래스에서 구현합니다.</p>

<p>일반메소드들은 실제 구현부가 {와 }로 사이에 존재를 합니다. 하지만, 특이하게도 추상 매소드는 {와 }가 없습니다.</p>

<p>함수의 호출처럼 메소드(); 형태로만 되어 있습니다. 즉 실체가 없기 때문에 추상적인 모습이라고 합니다.</p>

<p>오버라이딩
오버라이딩은 상위 클래스의 메소드를 하위 클래스에서 다시 재선언 하는 기능입니다. 추상 메소드를 사용하기 위해서는 상속받은 하위 클래스에서 추상 메소드를 오버라이딩 하여 구체적인 로직을 작성하여야 합니다.</p>

<p>강제
추상클래스는 상속을 통하여만 사용이 가능합니다. 혼자 독립적으로는 객체도 생성을 할 수 없습니다.</p>

<p>따라서 추상클래스는 상속을 하여 사용하도록 강제하는 효과가 있습니다. 그럼 왜 강제를 해야 하는가?</p>

<p>추상클래스 만들기
추상클래스를 만들기 위해서는 클래스명 앞에 abstract 키워드를 같이 적어 주어야 합니다.</p>

<p>책임의 전가
추상클래스의 메소드는 구제척인 로직이 없습니다. 상속받은 하위 클래스에서 이를 처리를 해야 합니다.이는 메소드의 구체적인 구현 책임을 하위 클래스로 넘기게 됩니다.</p>

<p>추상로직
상위의 추상 클래스에는 메소드의 정의만 되어 있습니다. Abstract로 정의된 메소드는 실제 구현 로직을 가지고 있으면 안됩니다.</p>

<p>실제 로직이 있는 메소드를 abstract 키워드로 추상화로 선언을 하게되면 오류가 발생합니다.</p>

<p>계층적 상속
추상 클래스를 계층적으로 상속을 합니다.</p>

<p>16.2 사용이유
추상 클래스를 한번에 잘 이해하기란 어렵습니다. 왜 어려운 추상 클래스를 사용해야 될까요?</p>

<p>강제
추상 클래스는 상속을 강제하기 위해서 사용합니다. 일반 적인 상속은 강제성이 없습니다.  선택적으로 상속여부를 결정할 수 있습니다. 이와 달리 인터페이스는 구현을 강제화 합니다. 인터페이스를 적용받게 되면, 선언된 메소드를 구현하여야 합니다.</p>

<p>추상클래스는 인터페이스의 강제성과 클래스의 상속 모드를 강제적으로 적용하게 할 수 있습니다.</p>

<p>그리고 이를 강제함으로서 책임을 하위 클래스로 위임을 하게 되는 것입니다.</p>

<p>대형 프로그램
이처럼 추상클래스를 통하여 상속을 강제하여 적용은 하는 것은 복잡합니다. 
자신의 개발 프로그램이 작은 경우 추상화 까지 할 필요는 없습니다. 하지만, 프로그램이 복잡할수록 체계적 구조를 가지는 것이 좋습니다.</p>

<p>체계적 구조를 강제로 설정을 하는 방법으로 추상화는 좋은 선택입니다.
많은 프레임워크들은 추상화를 통하여 상속을 강제화 하고, 매소드의 구현을 요구합니다.</p>

<p>공통부분
추상클래스도 일반 클래스와 같이 공통된 기능들을 묽어서 메소드로 구현을 할 수 있습니다. 그리고 구현된 메소드는 하위 클래스에서 사용이 가능합니다.</p>

<p>개별부분
상속은 공통된 로직들을 묽어서 상위 메소드로 제공을 할 수 있습니다. 하지만 각 클래스마다 다르게 동작해야 하는 개별 로직은 상위클래스에 넣을 수 없습니다.</p>

<p>추상화는 이러한 개별 코드를 메소드로 정의 합니다. 이는 마치 인터페이스의 선언과도 유사합니다. 추상 클래스를 강제로 상속하게 하여 개별 메소드를 하위 클래스에서 구현을 하도록 합니다.</p>

<p>패턴
추상 클래스를 잘 적용을 하기 위해서는 코드들의 공통된 패턴을 찾는 것이 중요합니다. 공통된 요구사항과 사용법이 있으며, 각기 다른 형태로 동작을 할 때
추상클래스는 매우 유용합니다.</p>

<p>구제적인 개별 메소드의 동작 처리는 사용자에게 구현을 위임을 합니다.</p>

<p>효용성
추상클래스는 공통된 부분과 공통되지 않는 부분이 썩여서 있는 경우 사용하기 좋은 클래스 유형입니다.</p>

<p>16.5 응용
추상클래스는 프로그램의 규모가 커질수록 매우 유용한 클래스 형식입니다. 객체지향에서는 다양한 문제를 해결하기 위한 해결 사례들을 모아 놓은 것이 있습니다. 이를 디자인 패턴이라고 합니다.</p>

<p>객체지향 디자인 패턴에서 다양한 문제를 해결을 하는데 추상 클래스를 자주 사용을 합니다. 추상 클래스를 정확하게 인지를 하지 못하고 있는면, 요즘 추세의 코드를 이해하기 쉽지 않습니다.</p>

<p>디자인 패턴을 추상클래스를 적용하여 설계를 합니다.</p>

<p>16.1.2 분리</p>

<p>16.1.3 선언
추상클래스는 상위에서 메소드의 이름만을 사전에 결정을 합니다. 구체 내용은 하위에서 생성을 하게 됩니다.</p>

<p>16.1.4 하위 책임
추상 클래스를 상속받은 하위 클래스는 상위 클래스에서 선언된 매소드를 구현할 책임이 있습니다.
이처럼 하위 클래스에 메소드의 구현의 책임을 넘기는 것을 하위 클래스 책임(subclass reponsibility)라고 합니다.</p>

<p>16.2 상속
클래스의 상속과 오버라이딩, 인터페이스를 세 가지의 클래스 확장 기능을 배웠습니다. 하지만 이중 상속과 인터페이스 두 개는 함께 사용할 수 없습니다. 즉, 상속과 인터페이스 규약을 혼합하여 사용할 수 없습니다.</p>

<p>이 두 개를 서로 같이 사용할 수 없는 이유는 상속과 인터페이스는 문법이 서로 매우 비슷합니다. 클래스명과 키워드 그리고 상속, 인터페이스명입니다.</p>

<p>class 클래스명 extends 상속 클래스
{
}</p>

<p>class 클래스명 implements 인터페이스
{
}</p>

<p>두 개의 기능을 콤마(,)등을 이용하여 구분하거나 연장해서 사용할 수 없다는 것입니다.</p>

<p>추상화는 이러한 문법적 유사점과 두 가지 기능을 유지하면서 두 개의 기능을 같이 사용하기 위한 것이 방법입니다. 즉, 추상화 = 상속 + 인터페이스 기능을 동시에 하고 싶을 때 사용되는 OOP 개념입니다.</p>

<p>15.4.1 추상화 문법</p>

<p>클래스에 추상화 사용법 또한 매우 간단합니다. 추상화 설정은  클래스명 또는 메서드 앞에 새로운 추상화 키워드 abstract를 같이 선언만 해주면 됩니다.</p>

<p>|문법|
abstract class 추상화 클래스
{
    // 추상화: 인터페이스
    abstract public function 메서드();</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>// 공통 메서드
public function copyright() {
    echo "copyright all Right JinyPHP";
} }
</code></pre></div></div>

<p>class 클래스명 extends 추상화 클래스
{
    public function 메서드() {
        return “abstract Method”;
    }
}</p>

<p>클래스를 정의할 때 abstract 키워드를 이용하여 추상화 클래스와 메서드 등을 생성합니다. 추상화로 선언한 메서드들은 인터페이스와 같이 자식 클래스에서 반드시 선언해야 합니다.</p>

<p>추상화 클래스를 적용하는 방법은 상속과 같이 extends 키워드로 사용합니다.</p>

<p>15.4.2 추상화 예제</p>

<p>예제 파일 abstract-01.php
&lt;?php</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>// 추상화 클래스를 선언합니다.
abstract class a
{
    // 확장 시 구현부가 필요한 메서드 정의
    abstract public function isAdult($age);
    
    public function copyright ()
    {
        // 본 메서드 함수는 대체되지 않습니다.
        echo "copyright all Right JinyPHP";
    }
}

// 추상화 적용
class b extends a
{
    // 추상화 인터페이스를 구현
    public function isAdult($age)
    {
        if ($age&gt;=18) return true; else return false;
    }
}

$obj = new b();

// 추상화에 선언된 일반 메서드를 상속, 호출 가능합니다.
$obj-&gt;copyright();

if ($obj-&gt;isAdult(18)){
    echo "성인입니다.";
} else {
    echo "미성년입니다.";
}
</code></pre></div></div>

<p>?&gt;</p>

<p>결과
copyright all Right JinyPHP 성인입니다.</p>

<p>위의 예제를 보면 추상화 클래스는 일반 클래스처럼 프로퍼티와 메서드 등을 구현할 수 있습니다. 또한 자식 클래스에서 다시 구현 처리해야 하는 인터페이스는 abstract 키워드를 추가하여 함께 선언합니다.</p>

<p>추상화 클래스를 상속받은 자식 클래스는 부모의 메서드 기능도 같이 상속받아 호출 사용 가능합니다. 또한 abstract로 선언한 인터페이스 메서드를 같이 구현해야 합니다.</p>

<p>추상화에서 선언된 인터페이스를 구현하지 않은 경우 PHP는 에러를 출력하고 PHP 코드를 더 이상 실행하지 않습니다. 이것은 인터페이스 규약을 따르지 않는 동작과 유사합니다.</p>

<p>추상 클래스
인스턴스
추상 클래스는 인스턴스를 만들 수 없습니다. 인스턴스를 생성하지 못하는 이유는 메서드의 본체가 없고, 선언만 되어 있기 때문입니다.
추상 클래스로는 구체적인 처리를 할 수 없습니다.
흐름제어
실제의 동작은 하위 클래스에서 결정이 됩니다. 하지만 동작의 처리 흐름은 추상클래스 단계에서 형성합니다.</p>

<p>클래스 협조
추상 클래스의 계층에서 상위 클래스와 하위클래스의 관계는 중요합니다. 상호 긴밀한 협조가 필요로 합니다.</p>

<p>추상클래스와 인터페이스
메소드를 미리 선언을 하는 측면에서 추상클래스와 인터페이스는 유사한 처리를 할 수 있습니다. 즉 상속, 구현되는 클래스에서 객체의 메소드를 강제로 구현하는 코드를 작성을 해야 하는 것입니다.
추상 클래스에 정의된 메소드를 구체적인 정의가 없이 거시적으로 이를 미리 사용을 할 수 있는 특징이 있습니다.</p>

<p>패턴 응용
추상 클래스는 템플릿 메소드 패턴에서 자주 응용되는 구현 처리 입니다.</p>

<p>추상클래스
공통된 내용을 추출하여 가상의 클래스에 정의합니다.
공통된 행위들은 일반화를 하여 상속 구조를 만듭니다.
추상클래스는 상속에서 부모 클래스/슈퍼클래스의 의미를 가진다.
하위 자식 클래스를 구체화 클래스라고 합니다.</p>

<p>공통기능
추상 클래스는 공통된 행위를 분리 합니다. 이를 통하여 중복을 제거하고 일반화 시킨 클래스 입니다.
그리고 이를 가상의 클래스 형태로 정의 합니다.
추상 클래스는 객체를 생성할 수 없습니다.</p>

<p>UML
추상 클래스를 표현을 할때에는 이텔릭체로 표현합니다.
상위 클래스는 함수만 선언이 가능합니다.</p>

<p>단일 인터페이스
추상화는 단일 인터페이스 입니다. 공통된 행위를 추출하고, 단일의 인터페이스를 생성합니다.
공통 인터페이스를 만들고, 외부에 서비스를 할때에는 동적 바인드 형태를 가집니다.</p>

<p>가상함수
추상클래스는 최소한 한개 이상의 가상 함수를 가지고 있여야 합니다.
하위 클래스에서는 다르게 구현되는 함수 템플릿을 가지고 있습니다.
추상 클래스에서는 행위에 대한 본체가 없지만, 상속받은 하위 클래스에서는 행위를 구현하여야 합니다.</p>

<p>특성
상속 구조에서 추상 클래스는 자주 사용이 됩니다.
재사용성
공통된 내용을 추출함으로써 재사용을 증가 합니다.
대체성
추상 클래스도 is-A 관계가 성립이 됩니다. 서브 클래스 객체가 대치될 수 잇습니다.
다른 객체
서로 다른 하위 객체를 생성할 수 있습니다. 이는 추상 클래스의 장점 입니다.
이를 통하여 각기 다른 하위 클래스들을 생성을 할 수 있습니다.</p>

<p>유지보수성
추상클래스에 정의된 가상 함수는 언제든지 재구현이 가능합니다. 이는 기존의 코드에 영향을 적게 받는 것입니다.
영향이 적으면, 수정과 유지 보수가 편리합니다.</p>

<p>확장성
새로운 행위를 추가하기 쉽니다.</p>

<p>UML
UML에서 추상클래스를 표현하는 방법은 « » 스트레오 타입을 사용하는 것입니다.</p>

<p>구현
추상 클래스를 구현할때에는 abstract 키워드를 같이 사용을 합니다.
C++과 같은 언어에서는 virtual 이라는 키워드를 사용합니다.</p>

:ET